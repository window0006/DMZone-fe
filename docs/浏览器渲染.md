# 浏览器渲染原理

## DOM
* DOM是生成页面的基础数据结构
* DOM提供js api

DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容。

### DOM树生成过程
> HTML解析器：将HTML字节流转换成DOM结构。接收多少就解析多少。

* 网络进程在接收到响应数据之后，从`响应头`检查是`content-type`是否为`text/html`。
* 为`content-type`值为`text/html`的请求选择或者创建一个渲染进程。
* 渲染进程准备好后，网络进程和渲染进程之间会建立一个共享数据的管道，将网络下载的请求内容通过这个管道传送给渲染进程，渲染进程动态解析HTML内容，生成对应的DOM结构。
  * 通过`分词器`将HTML字节流转换成`Token`；
    * 起始标签
    * 结束标签
    * 栈结构，起始标签入栈，结束标签则出栈。
  * 将`Token`解析成`DOM节点`，并添加到DOM树中。
  * 如果遇到`<script>`标签，则暂停DOM的解析，因为js可能会修改已有的DOM结构
    * js引擎介入
    * 执行`<script>`标签中的代码，执行完后恢复DOM的继续解析
  * 如果遇到引入外部js文件的`<script>`标签，同样会暂停DOM的解析，同时会等待对应的js下载完成，再执行对应的js
    * 浏览器会有`预解析操作`的优化，当渲染进程接收到HTML字节流后，会启动一个`预解析线程`，分析HTML中的静态资源，提前开始下载这些文件。
    * 可以使用`async`、`defer`来规避DOM被阻塞解析的问题。
      * async标记的script标签文件一旦加载，会立即执行
      * defer标记的script标签文件则会在`DOMContentLoad`事件后执行

## CSS 
> CSS解析器：将CSS字节流转换成CSSOM结构。
### CSSOM
* 提供给js操作CSS的jsapi
* 为布局树的合成提供基础的样式信息

* 渲染引擎在解析（或预解析）HTML字节流构建DOM的过程中，遇到CSS资源，会让网络进程同步下载对应的资源

## 页面渲染
### 显示器如何显示图像
* `显示器`的固定个刷新率一般是60HZ，也就是每秒更新 60 张图片。每秒读取60次`前缓冲区`中的图片，将读取的图像显示到显示器上。
* `显卡`合成新的图像，并将图像保存到`后缓冲`区中。一旦后缓冲区图像更新，系统会让后缓冲区和前缓冲区互换，保证显示器读取到的是最新的图像。显卡的更新频率和显示器的刷新频率是一致的，但是复杂场景中，显卡生成图像的速度慢，将导致掉帧。
  * 重排：重新根据 CSSOM 和 DOM 来计算布局树，耗时很长
  * 重绘：依然需要重新计算绘制信息，并触发绘制操作之后的一系列操作。
  * 合成：使用GPU效率会非常高。

### 分成和合成
为了提升每帧的渲染效率，Chrome 引入了分层和合成的机制。
* 分层体现在生成布局树之后
* 绘制阶段其实并不是真正地绘出图片，而是将绘制指令组合成一个列表。
* 有了绘制列表之后，就需要进入光栅化阶段，按照绘制列表中的指令生成图片。
* 每一个图层都对应一张图片
* 合成线程有了这些图片之后，会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区。
合成线程和主线程的分离的，js卡住，并不会影响css动画合成

### 分块渲染
优先绘制靠近视口的图块，加速页面的显示速度。
纹理上传：从计算机内存上传到 GPU 内存，这里会比较慢，浏览的优化手段是在首次合成图块的时候使用一个低分辨率的图片，使用较小的纹理。

